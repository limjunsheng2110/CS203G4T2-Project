name: CI/CD Pipeline - Full Stack Microservices Deployment

on:
  # 1. Continuous Integration (Run on PRs for validation)
  pull_request:
    branches: [ main ] # Runs when a PR is opened/updated targeting 'main'

  # 2. Continuous Delivery (Run ONLY on push to stable branch, after merge)
  push:
    branches: [ main ] # Change 'main' to your default branch if different

jobs:
  build_and_publish:
    runs-on: ubuntu-latest

    # Grant necessary permissions for reading code and pushing packages/images
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # 1. BUILD AND TEST SPRING BOOT BACKEND
      # -----------------------------------------------------------------------
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build and Test Spring Boot application
        env:
          # Only pass non-database secrets for tests
          # Tests use H2 in-memory database configured in src/test/resources/application.properties
          OPENAI_API_KEY: ${{ secrets.OPENAI_KEY }}
          OPENEXCHANGERATES_API_KEY: ${{ secrets.OPENEXCHANGERATES_API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: mvn clean package

      # -----------------------------------------------------------------------
      # 2. SETUP DOCKER FOR MULTI-SERVICE BUILD
      # -----------------------------------------------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }} # Use your Docker registry password secret

      # -----------------------------------------------------------------------
      # 3. BUILD AND PUSH SPRING BOOT BACKEND IMAGE
      # -----------------------------------------------------------------------
      - name: Build and Push Backend Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest


      # -----------------------------------------------------------------------
      # 4. BUILD AND PUSH PYTHON SCRAPER IMAGE
      # -----------------------------------------------------------------------
      - name: Build and Push Python Scraper Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./tariff-scraper
          file: ./tariff-scraper/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest

      - name: Upload JAR as an Artifact (For backup/review)
        uses: actions/upload-artifact@v4
        with:
          name: jar-artifacts
          path: target/tariffg4t2-0.0.1-SNAPSHOT.jar # <--- Confirmed JAR Name

  # -----------------------------------------------------------------------
  # 5. DEPLOY MICROSERVICES TO EC2
  # -----------------------------------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: build_and_publish # This dependency ensures the job only runs if the image push succeeded

    steps:
      - name: Deploy Microservices via SSH
        # Uses the community action to execute commands on the remote EC2 server
        uses: appleboy/ssh-action@v1.0.1
        with:
          # SSH Credentials passed securely from GitHub Secrets
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}

          # üö® Deployment Script (Run these commands on the EC2 server) üö®
          script: |
            # Login to Docker Hub
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

            # Create docker network if it doesn't exist
            docker network create tariff-network || true

            # Pull latest images
            docker pull ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest
            docker pull ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest
            docker pull nginx:alpine

            # Stop and remove existing containers gracefully
            docker stop tariff-nginx tariff-backend tariff-scraper 2>/dev/null || true
            docker rm tariff-nginx tariff-backend tariff-scraper 2>/dev/null || true

            # Deploy Python Scraper first
            echo "üêç Starting Python Scraper..."
            docker run -d \
              --name tariff-scraper \
              --network tariff-network \
              -p 5001:5001 \
              --restart unless-stopped \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_KEY }}" \
              ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest

            # Deploy Spring Boot Backend
            echo "‚òï Starting Spring Boot Backend..."
            docker run -d \
              --name tariff-backend \
              --network tariff-network \
              -p 8080:8080 \
              --restart unless-stopped \
              -e DB_URL="${{ secrets.DB_URL }}" \
              -e DB_USERNAME="${{ secrets.DB_USERNAME }}" \
              -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
              -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              -e JWT_EXPIRATION_MS="900000" \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_KEY }}" \
              -e OPENEXCHANGERATES_API_KEY="${{ secrets.OPENEXCHANGERATES_API_KEY }}" \
              -e PYTHON_SCRAPER_URL="http://tariff-scraper:5001/scrape" \
              ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest

            # Wait for services to start (simple time-based approach)
            echo "‚è≥ Waiting for services to initialize..."
            sleep 60

            # Create nginx config with simpler approach that works reliably
            echo "üåê Starting Nginx Reverse Proxy..."
            
            # Create a simple nginx config file on the host first
            cat > /tmp/nginx.conf << 'EOF'
            events {
                worker_connections 1024;
            }

            http {
                upstream backend {
                    server tariff-backend:8080;
                }

                upstream python-scraper {
                    server tariff-scraper:5001;
                }

                server {
                    listen 80;
                    server_name _;

                    # Enable CORS for frontend
                    add_header Access-Control-Allow-Origin "*" always;
                    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                    add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;

                    # Handle preflight requests
                    if ($request_method = 'OPTIONS') {
                        add_header Access-Control-Allow-Origin "*";
                        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
                        add_header Content-Length 0;
                        add_header Content-Type text/plain;
                        return 204;
                    }

                    # Backend API routes
                    location /api/ {
                        proxy_pass http://backend;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }

                    # Auth routes
                    location /auth/ {
                        proxy_pass http://backend;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }

                    # Swagger/OpenAPI routes
                    location /swagger-ui/ {
                        proxy_pass http://backend/swagger-ui/;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                        proxy_redirect off;
                    }

                    location /swagger-ui {
                        return 301 /swagger-ui/;
                    }

                    location /v3/api-docs {
                        proxy_pass http://backend/v3/api-docs;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }

                    # Python scraper routes
                    location /scrape/ {
                        proxy_pass http://python-scraper/;
                        proxy_set_header Host $host;
                        proxy_set_header X-Real-IP $remote_addr;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto $scheme;
                    }

                    # Health check
                    location /health {
                        access_log off;
                        return 200 "healthy\n";
                        add_header Content-Type text/plain;
                    }
                }
            }
            EOF

            # Start nginx with the config file
            docker run -d \
              --name tariff-nginx \
              --network tariff-network \
              -p 80:80 \
              -p 443:443 \
              -v /tmp/nginx.conf:/etc/nginx/nginx.conf:ro \
              --restart unless-stopped \
              nginx:alpine

            # Wait for nginx to start
            sleep 10

            # Final verification
            echo "üîç Final deployment verification..."
            echo "==================================="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            
            # Test endpoints with simpler approach
            echo "üß™ Testing endpoints..."
            if timeout 5 bash -c "</dev/tcp/localhost/80" 2>/dev/null; then
              echo "‚úÖ Nginx (port 80): ACCESSIBLE"
            else
              echo "‚ùå Nginx (port 80): NOT ACCESSIBLE"
            fi

            if timeout 5 bash -c "</dev/tcp/localhost/8080" 2>/dev/null; then
              echo "‚úÖ Backend (port 8080): ACCESSIBLE"
            else
              echo "‚ùå Backend (port 8080): NOT ACCESSIBLE"
            fi

            if timeout 5 bash -c "</dev/tcp/localhost/5001" 2>/dev/null; then
              echo "‚úÖ Scraper (port 5001): ACCESSIBLE"
            else
              echo "‚ùå Scraper (port 5001): NOT ACCESSIBLE"
            fi

            echo ""
            echo "üöÄ Deployment Summary:"
            echo "====================="
            echo "üåê Your microservices are deployed at:"
            echo "‚úÖ Backend API: http://52.65.58.208/api/"
            echo "‚úÖ Authentication: http://52.65.58.208/auth/"
            echo "‚úÖ Python Scraper: http://52.65.58.208/scrape/"
            echo "‚úÖ Swagger UI: http://52.65.58.208/swagger-ui/"
            echo "‚úÖ Health Check: http://52.65.58.208/health"
            echo ""
            echo "üìä Service Status:"
            docker ps --filter "name=tariff-" --format "{{.Names}}: {{.Status}}"
