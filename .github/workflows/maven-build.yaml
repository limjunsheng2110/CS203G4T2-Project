name: CI/CD Pipeline - Full Stack Microservices Deployment

on:
  # 1. Continuous Integration (Run on PRs for validation)
  pull_request:
    branches: [ main ] # Runs when a PR is opened/updated targeting 'main'

  # 2. Continuous Delivery (Run ONLY on push to stable branch, after merge)
  push:
    branches: [ main ] # Change 'main' to your default branch if different

jobs:
  build_and_publish:
    runs-on: ubuntu-latest

    # Grant necessary permissions for reading code and pushing packages/images
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # 1. BUILD AND TEST SPRING BOOT BACKEND
      # -----------------------------------------------------------------------
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build and Test Spring Boot application
        env:
          # Only pass non-database secrets for tests
          # Tests use H2 in-memory database configured in src/test/resources/application.properties
          OPENAI_API_KEY: ${{ secrets.OPENAI_KEY }}
          OPENEXCHANGERATES_API_KEY: ${{ secrets.OPENEXCHANGERATES_API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: mvn clean package

      # -----------------------------------------------------------------------
      # 2. SETUP DOCKER FOR MULTI-SERVICE BUILD
      # -----------------------------------------------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }} # Use your Docker registry password secret

      # -----------------------------------------------------------------------
      # 3. BUILD AND PUSH SPRING BOOT BACKEND IMAGE
      # -----------------------------------------------------------------------
      - name: Build and Push Backend Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest


      # -----------------------------------------------------------------------
      # 4. BUILD AND PUSH PYTHON SCRAPER IMAGE
      # -----------------------------------------------------------------------
      - name: Build and Push Python Scraper Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./tariff-scraper
          file: ./tariff-scraper/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest

      - name: Upload JAR as an Artifact (For backup/review)
        uses: actions/upload-artifact@v4
        with:
          name: jar-artifacts
          path: target/tariffg4t2-0.0.1-SNAPSHOT.jar # <--- Confirmed JAR Name

  # -----------------------------------------------------------------------
  # 5. DEPLOY MICROSERVICES TO EC2
  # -----------------------------------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: build_and_publish # This dependency ensures the job only runs if the image push succeeded

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy nginx.conf to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "nginx.conf"
          target: "/tmp/"

      - name: Deploy Microservices via SSH
        # Uses the community action to execute commands on the remote EC2 server
        uses: appleboy/ssh-action@v1.0.1
        with:
          # SSH Credentials passed securely from GitHub Secrets
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}

          # üö® Deployment Script (Run these commands on the EC2 server) üö®
          script: |
            # Login to Docker Hub
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

            # Create docker network if it doesn't exist
            docker network create tariff-network || true

            # Pull latest images
            docker pull ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest
            docker pull ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest
            docker pull nginx:alpine

            # Stop and remove existing containers gracefully
            docker run -d \
            echo "üõë Stopping existing containers..."
              --name tariff-scraper \
              --network tariff-network \
              -p 5001:5001 \
            # Remove old images to force fresh pull
            echo "üßπ Cleaning up old images..."
            docker rmi ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest 2>/dev/null || true
            docker rmi ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest 2>/dev/null || true

            # Pull latest images with --no-cache
            echo "üì• Pulling latest images..."
            docker pull --no-cache ${{ secrets.DOCKER_USERNAME }}/tariff-backend:latest
            docker pull --no-cache ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest
            docker pull nginx:alpine

              --restart unless-stopped \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_KEY }}" \
              ${{ secrets.DOCKER_USERNAME }}/tariff-scraper:latest

            # Deploy Spring Boot Backend
            echo "‚òï Starting Spring Boot Backend..."
            docker run -d \
              --name tariff-backend \
              --network tariff-network \
              -p 8080:8080 \
              --restart unless-stopped \
              -e DB_URL="${{ secrets.DB_URL }}" \
              -e DB_USERNAME="${{ secrets.DB_USERNAME }}" \
              -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
              -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              -e JWT_EXPIRATION_MS="900000" \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_KEY }}" \
              -e SPRING_DATASOURCE_URL="${{ secrets.DB_URL }}" \
              -e SPRING_DATASOURCE_USERNAME="${{ secrets.DB_USERNAME }}" \
              -e SPRING_DATASOURCE_PASSWORD="${{ secrets.DB_PASSWORD }}" \

            # Wait for services to start (simple time-based approach)
            echo "‚è≥ Waiting for services to initialize..."
            sleep 30

              -e SPRING_PROFILES_ACTIVE="prod" \
            # Deploy Nginx using the config file from the repository
            echo "üåê Starting Nginx Reverse Proxy..."
            
            # Test nginx config before starting container
            echo "üîß Testing nginx configuration..."
            docker run --rm -v /tmp/nginx.conf:/etc/nginx/nginx.conf:ro nginx:alpine nginx -t

            # Start nginx with the config file from the repository
            docker run -d \
              --name tariff-nginx \
              --network tariff-network \
              -p 80:80 \
              -v /tmp/nginx.conf:/etc/nginx/nginx.conf:ro \
              --restart unless-stopped \
              nginx:alpine

            # Wait for nginx to start and check its status immediately
            sleep 5
            echo "üîç Checking nginx status immediately after start..."
            docker ps --filter "name=tariff-nginx" --format "{{.Names}}: {{.Status}}"
            
            # If nginx is not running, show logs
            if ! docker ps --filter "name=tariff-nginx" --filter "status=running" | grep -q tariff-nginx; then
              echo "‚ùå Nginx failed to start! Showing logs:"
              docker logs tariff-nginx
            fi

            # Wait a bit more and check again
            sleep 10

            # Final verification
            echo "üîç Final deployment verification..."
            echo "==================================="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            
            # Cleanup old unused images
            echo "üßπ Cleaning up old unused images..."
            docker image prune -f

            # Test endpoints with simpler approach
            echo "üß™ Testing endpoints..."
            if timeout 5 bash -c "</dev/tcp/localhost/80" 2>/dev/null; then
              echo "‚úÖ Nginx (port 80): ACCESSIBLE"
            else
              echo "‚ùå Nginx (port 80): NOT ACCESSIBLE"
            fi

            if timeout 5 bash -c "</dev/tcp/localhost/8080" 2>/dev/null; then
              echo "‚úÖ Backend (port 8080): ACCESSIBLE"
            else
              echo "‚ùå Backend (port 8080): NOT ACCESSIBLE"
            fi

            if timeout 5 bash -c "</dev/tcp/localhost/5001" 2>/dev/null; then
              echo "‚úÖ Scraper (port 5001): ACCESSIBLE"
            else
              echo "‚ùå Scraper (port 5001): NOT ACCESSIBLE"
            fi

            echo ""
            echo "üöÄ Deployment Summary:"
            echo "====================="
            echo "üåê Your microservices are deployed at:"
            echo "‚úÖ Backend API: http://52.65.58.208/api/"
            echo "‚úÖ Authentication: http://52.65.58.208/auth/"
            echo "‚úÖ Python Scraper: http://52.65.58.208/scrape/"
            echo "‚úÖ Swagger UI: http://52.65.58.208/swagger-ui/"
            echo "‚úÖ Health Check: http://52.65.58.208/health"
            echo ""
            echo "üìä Service Status:"
            docker ps --filter "name=tariff-" --format "{{.Names}}: {{.Status}}"
