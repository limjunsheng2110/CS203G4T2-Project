#on:
#  push:
#    branches:
#      - main
#  pull_request:
#    branches:
#      - main
name: CI/CD Pipeline - Maven Build, Test, Dockerize, and Publish

on:
  # 1. Continuous Integration (Run on PRs for validation)
  pull_request:
    branches: [ main ] # Runs when a PR is opened/updated targeting 'main'

  # 2. Continuous Delivery (Run ONLY on push to stable branch, after merge)
  push:
    branches: [ main ] # Change 'main' to your default branch if different


jobs:
  build_and_publish:
    runs-on: ubuntu-latest

    # Grant necessary permissions for reading code and pushing packages/images
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # 1. CONTINUOUS INTEGRATION (CI) PHASE: Build and Test Java Application
      # -----------------------------------------------------------------------

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build and Test application
        env:
          # Explicitly pass the secrets as environment variables for this step
          SPRING_DATASOURCE_URL: ${{ secrets.DB_URL }}
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
          SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_KEY }}
          OPENEXCHANGERATES_API_KEY: ${{ secrets.OPENEXCHANGERATES_API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: mvn clean package

      # -----------------------------------------------------------------------
      # 2. CONTINUOUS DELIVERY (CD) PHASE: Dockerize and Publish
      # -----------------------------------------------------------------------

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }} # Use your Docker registry password secret

      - name: Extract metadata (tags, labels) for Docker Image
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/tariff-app # <--- RENAME YOUR APP HERE
          tags: |
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and Push Docker Image (with Secrets)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

          # ðŸš¨ INJECT APPLICATION SECRETS AS BUILD ARGUMENTS ðŸš¨
          # These are mapped from GitHub Secrets to ARGs in your Dockerfile
          build-args: |
            SPRING_DATASOURCE_URL=${{ secrets.DB_URL }}
            SPRING_DATASOURCE_USERNAME=${{ secrets.DB_USERNAME }}
            SPRING_DATASOURCE_PASSWORD=${{ secrets.DB_PASSWORD }}
            OPENAI_API_KEY=${{ secrets.OPENAI_KEY }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            OPENEXCHANGERATES_API_KEY: ${{ secrets.OPENEXCHANGERATES_API_KEY }}


      # -----------------------------------------------------------------------
      # 3. CLEANUP (Optional)
      # -----------------------------------------------------------------------

      - name: Upload JAR as an Artifact (For backup/review)
        uses: actions/upload-artifact@v4
        with:
          name: jar-artifacts
          path: target/tariffg4t2-0.0.1-SNAPSHOT.jar # <--- Confirmed JAR Name


  #Deploy
    # ... (after the 'build_and_publish' job ends)

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_publish # This dependency ensures the job only runs if the image push succeeded

    steps:
      - name: Deploy via SSH and Restart Container
        # Uses the community action to execute commands on the remote EC2 server
        uses: appleboy/ssh-action@v1.0.1
        with:
          # SSH Credentials passed securely from GitHub Secrets
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}

          # ðŸš¨ Deployment Script (Run these commands on the EC2 server) ðŸš¨
          script: |
            # 1. Log into Docker Hub on the EC2 instance to pull the image
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

            # 2. Define image name (Must match the name pushed in the first job)
            IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/tariff-app:latest
            CONTAINER_NAME=tariff-app-container

            echo "Pulling new image: $IMAGE_NAME"
            docker pull $IMAGE_NAME

            # 3. Stop and remove old container (if running)
            echo "Restarting application container..."
            docker stop $CONTAINER_NAME || true 
            docker rm $CONTAINER_NAME || true 

            # 4. Run the new container, mapping the application port
            docker run -d \
              --name $CONTAINER_NAME \
              -e SPRING_DATASOURCE_URL="${{ secrets.DB_URL }}" \
              -e SPRING_DATASOURCE_PASSWORD="${{ secrets.DB_PASSWORD }}" \
              -e SPRING_DATASOURCE_USERNAME="${{ secrets.DB_USERNAME }}" \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_KEY }}" \
              -e OPENEXCHANGERATES_API_KEY="${{ secrets.OPENEXCHANGERATES_API_KEY }}" \
              -p 8080:8080 \
              $IMAGE_NAME